{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Kaleidoscope = void 0;\nconst Factory_1 = require(\"../Factory\");\nconst Node_1 = require(\"../Node\");\nconst Util_1 = require(\"../Util\");\nconst Validators_1 = require(\"../Validators\");\nconst ToPolar = function (src, dst, opt) {\n  const srcPixels = src.data,\n    dstPixels = dst.data,\n    xSize = src.width,\n    ySize = src.height,\n    xMid = opt.polarCenterX || xSize / 2,\n    yMid = opt.polarCenterY || ySize / 2;\n  let rMax = Math.sqrt(xMid * xMid + yMid * yMid);\n  let x = xSize - xMid;\n  let y = ySize - yMid;\n  const rad = Math.sqrt(x * x + y * y);\n  rMax = rad > rMax ? rad : rMax;\n  const rSize = ySize,\n    tSize = xSize;\n  const conversion = 360 / tSize * Math.PI / 180;\n  for (let theta = 0; theta < tSize; theta += 1) {\n    const sin = Math.sin(theta * conversion);\n    const cos = Math.cos(theta * conversion);\n    for (let radius = 0; radius < rSize; radius += 1) {\n      x = Math.floor(xMid + rMax * radius / rSize * cos);\n      y = Math.floor(yMid + rMax * radius / rSize * sin);\n      let i = (y * xSize + x) * 4;\n      const r = srcPixels[i + 0];\n      const g = srcPixels[i + 1];\n      const b = srcPixels[i + 2];\n      const a = srcPixels[i + 3];\n      i = (theta + radius * xSize) * 4;\n      dstPixels[i + 0] = r;\n      dstPixels[i + 1] = g;\n      dstPixels[i + 2] = b;\n      dstPixels[i + 3] = a;\n    }\n  }\n};\nconst FromPolar = function (src, dst, opt) {\n  const srcPixels = src.data,\n    dstPixels = dst.data,\n    xSize = src.width,\n    ySize = src.height,\n    xMid = opt.polarCenterX || xSize / 2,\n    yMid = opt.polarCenterY || ySize / 2;\n  let rMax = Math.sqrt(xMid * xMid + yMid * yMid);\n  let x = xSize - xMid;\n  let y = ySize - yMid;\n  const rad = Math.sqrt(x * x + y * y);\n  rMax = rad > rMax ? rad : rMax;\n  const rSize = ySize,\n    tSize = xSize,\n    phaseShift = opt.polarRotation || 0;\n  let x1, y1;\n  for (x = 0; x < xSize; x += 1) {\n    for (y = 0; y < ySize; y += 1) {\n      const dx = x - xMid;\n      const dy = y - yMid;\n      const radius = Math.sqrt(dx * dx + dy * dy) * rSize / rMax;\n      let theta = (Math.atan2(dy, dx) * 180 / Math.PI + 360 + phaseShift) % 360;\n      theta = theta * tSize / 360;\n      x1 = Math.floor(theta);\n      y1 = Math.floor(radius);\n      let i = (y1 * xSize + x1) * 4;\n      const r = srcPixels[i + 0];\n      const g = srcPixels[i + 1];\n      const b = srcPixels[i + 2];\n      const a = srcPixels[i + 3];\n      i = (y * xSize + x) * 4;\n      dstPixels[i + 0] = r;\n      dstPixels[i + 1] = g;\n      dstPixels[i + 2] = b;\n      dstPixels[i + 3] = a;\n    }\n  }\n};\nconst Kaleidoscope = function (imageData) {\n  const xSize = imageData.width,\n    ySize = imageData.height;\n  let x, y, xoff, i, r, g, b, a, srcPos, dstPos;\n  let power = Math.round(this.kaleidoscopePower());\n  const angle = Math.round(this.kaleidoscopeAngle());\n  const offset = Math.floor(xSize * (angle % 360) / 360);\n  if (power < 1) {\n    return;\n  }\n  const tempCanvas = Util_1.Util.createCanvasElement();\n  tempCanvas.width = xSize;\n  tempCanvas.height = ySize;\n  const scratchData = tempCanvas.getContext('2d').getImageData(0, 0, xSize, ySize);\n  Util_1.Util.releaseCanvas(tempCanvas);\n  ToPolar(imageData, scratchData, {\n    polarCenterX: xSize / 2,\n    polarCenterY: ySize / 2\n  });\n  let minSectionSize = xSize / Math.pow(2, power);\n  while (minSectionSize <= 8) {\n    minSectionSize = minSectionSize * 2;\n    power -= 1;\n  }\n  minSectionSize = Math.ceil(minSectionSize);\n  let sectionSize = minSectionSize;\n  let xStart = 0,\n    xEnd = sectionSize,\n    xDelta = 1;\n  if (offset + minSectionSize > xSize) {\n    xStart = sectionSize;\n    xEnd = 0;\n    xDelta = -1;\n  }\n  for (y = 0; y < ySize; y += 1) {\n    for (x = xStart; x !== xEnd; x += xDelta) {\n      xoff = Math.round(x + offset) % xSize;\n      srcPos = (xSize * y + xoff) * 4;\n      r = scratchData.data[srcPos + 0];\n      g = scratchData.data[srcPos + 1];\n      b = scratchData.data[srcPos + 2];\n      a = scratchData.data[srcPos + 3];\n      dstPos = (xSize * y + x) * 4;\n      scratchData.data[dstPos + 0] = r;\n      scratchData.data[dstPos + 1] = g;\n      scratchData.data[dstPos + 2] = b;\n      scratchData.data[dstPos + 3] = a;\n    }\n  }\n  for (y = 0; y < ySize; y += 1) {\n    sectionSize = Math.floor(minSectionSize);\n    for (i = 0; i < power; i += 1) {\n      for (x = 0; x < sectionSize + 1; x += 1) {\n        srcPos = (xSize * y + x) * 4;\n        r = scratchData.data[srcPos + 0];\n        g = scratchData.data[srcPos + 1];\n        b = scratchData.data[srcPos + 2];\n        a = scratchData.data[srcPos + 3];\n        dstPos = (xSize * y + sectionSize * 2 - x - 1) * 4;\n        scratchData.data[dstPos + 0] = r;\n        scratchData.data[dstPos + 1] = g;\n        scratchData.data[dstPos + 2] = b;\n        scratchData.data[dstPos + 3] = a;\n      }\n      sectionSize *= 2;\n    }\n  }\n  FromPolar(scratchData, imageData, {\n    polarRotation: 0\n  });\n};\nexports.Kaleidoscope = Kaleidoscope;\nFactory_1.Factory.addGetterSetter(Node_1.Node, 'kaleidoscopePower', 2, (0, Validators_1.getNumberValidator)(), Factory_1.Factory.afterSetFilter);\nFactory_1.Factory.addGetterSetter(Node_1.Node, 'kaleidoscopeAngle', 0, (0, Validators_1.getNumberValidator)(), Factory_1.Factory.afterSetFilter);","map":{"version":3,"names":["Object","defineProperty","exports","value","Kaleidoscope","Factory_1","require","Node_1","Util_1","Validators_1","ToPolar","src","dst","opt","srcPixels","data","dstPixels","xSize","width","ySize","height","xMid","polarCenterX","yMid","polarCenterY","rMax","Math","sqrt","x","y","rad","rSize","tSize","conversion","PI","theta","sin","cos","radius","floor","i","r","g","b","a","FromPolar","phaseShift","polarRotation","x1","y1","dx","dy","atan2","imageData","xoff","srcPos","dstPos","power","round","kaleidoscopePower","angle","kaleidoscopeAngle","offset","tempCanvas","Util","createCanvasElement","scratchData","getContext","getImageData","releaseCanvas","minSectionSize","pow","ceil","sectionSize","xStart","xEnd","xDelta","Factory","addGetterSetter","Node","getNumberValidator","afterSetFilter"],"sources":["C:/Users/tharu/Downloads/mini-layout-editor/mini-layout-editor/node_modules/konva/lib/filters/Kaleidoscope.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Kaleidoscope = void 0;\nconst Factory_1 = require(\"../Factory\");\nconst Node_1 = require(\"../Node\");\nconst Util_1 = require(\"../Util\");\nconst Validators_1 = require(\"../Validators\");\nconst ToPolar = function (src, dst, opt) {\n    const srcPixels = src.data, dstPixels = dst.data, xSize = src.width, ySize = src.height, xMid = opt.polarCenterX || xSize / 2, yMid = opt.polarCenterY || ySize / 2;\n    let rMax = Math.sqrt(xMid * xMid + yMid * yMid);\n    let x = xSize - xMid;\n    let y = ySize - yMid;\n    const rad = Math.sqrt(x * x + y * y);\n    rMax = rad > rMax ? rad : rMax;\n    const rSize = ySize, tSize = xSize;\n    const conversion = ((360 / tSize) * Math.PI) / 180;\n    for (let theta = 0; theta < tSize; theta += 1) {\n        const sin = Math.sin(theta * conversion);\n        const cos = Math.cos(theta * conversion);\n        for (let radius = 0; radius < rSize; radius += 1) {\n            x = Math.floor(xMid + ((rMax * radius) / rSize) * cos);\n            y = Math.floor(yMid + ((rMax * radius) / rSize) * sin);\n            let i = (y * xSize + x) * 4;\n            const r = srcPixels[i + 0];\n            const g = srcPixels[i + 1];\n            const b = srcPixels[i + 2];\n            const a = srcPixels[i + 3];\n            i = (theta + radius * xSize) * 4;\n            dstPixels[i + 0] = r;\n            dstPixels[i + 1] = g;\n            dstPixels[i + 2] = b;\n            dstPixels[i + 3] = a;\n        }\n    }\n};\nconst FromPolar = function (src, dst, opt) {\n    const srcPixels = src.data, dstPixels = dst.data, xSize = src.width, ySize = src.height, xMid = opt.polarCenterX || xSize / 2, yMid = opt.polarCenterY || ySize / 2;\n    let rMax = Math.sqrt(xMid * xMid + yMid * yMid);\n    let x = xSize - xMid;\n    let y = ySize - yMid;\n    const rad = Math.sqrt(x * x + y * y);\n    rMax = rad > rMax ? rad : rMax;\n    const rSize = ySize, tSize = xSize, phaseShift = opt.polarRotation || 0;\n    let x1, y1;\n    for (x = 0; x < xSize; x += 1) {\n        for (y = 0; y < ySize; y += 1) {\n            const dx = x - xMid;\n            const dy = y - yMid;\n            const radius = (Math.sqrt(dx * dx + dy * dy) * rSize) / rMax;\n            let theta = ((Math.atan2(dy, dx) * 180) / Math.PI + 360 + phaseShift) % 360;\n            theta = (theta * tSize) / 360;\n            x1 = Math.floor(theta);\n            y1 = Math.floor(radius);\n            let i = (y1 * xSize + x1) * 4;\n            const r = srcPixels[i + 0];\n            const g = srcPixels[i + 1];\n            const b = srcPixels[i + 2];\n            const a = srcPixels[i + 3];\n            i = (y * xSize + x) * 4;\n            dstPixels[i + 0] = r;\n            dstPixels[i + 1] = g;\n            dstPixels[i + 2] = b;\n            dstPixels[i + 3] = a;\n        }\n    }\n};\nconst Kaleidoscope = function (imageData) {\n    const xSize = imageData.width, ySize = imageData.height;\n    let x, y, xoff, i, r, g, b, a, srcPos, dstPos;\n    let power = Math.round(this.kaleidoscopePower());\n    const angle = Math.round(this.kaleidoscopeAngle());\n    const offset = Math.floor((xSize * (angle % 360)) / 360);\n    if (power < 1) {\n        return;\n    }\n    const tempCanvas = Util_1.Util.createCanvasElement();\n    tempCanvas.width = xSize;\n    tempCanvas.height = ySize;\n    const scratchData = tempCanvas\n        .getContext('2d')\n        .getImageData(0, 0, xSize, ySize);\n    Util_1.Util.releaseCanvas(tempCanvas);\n    ToPolar(imageData, scratchData, {\n        polarCenterX: xSize / 2,\n        polarCenterY: ySize / 2,\n    });\n    let minSectionSize = xSize / Math.pow(2, power);\n    while (minSectionSize <= 8) {\n        minSectionSize = minSectionSize * 2;\n        power -= 1;\n    }\n    minSectionSize = Math.ceil(minSectionSize);\n    let sectionSize = minSectionSize;\n    let xStart = 0, xEnd = sectionSize, xDelta = 1;\n    if (offset + minSectionSize > xSize) {\n        xStart = sectionSize;\n        xEnd = 0;\n        xDelta = -1;\n    }\n    for (y = 0; y < ySize; y += 1) {\n        for (x = xStart; x !== xEnd; x += xDelta) {\n            xoff = Math.round(x + offset) % xSize;\n            srcPos = (xSize * y + xoff) * 4;\n            r = scratchData.data[srcPos + 0];\n            g = scratchData.data[srcPos + 1];\n            b = scratchData.data[srcPos + 2];\n            a = scratchData.data[srcPos + 3];\n            dstPos = (xSize * y + x) * 4;\n            scratchData.data[dstPos + 0] = r;\n            scratchData.data[dstPos + 1] = g;\n            scratchData.data[dstPos + 2] = b;\n            scratchData.data[dstPos + 3] = a;\n        }\n    }\n    for (y = 0; y < ySize; y += 1) {\n        sectionSize = Math.floor(minSectionSize);\n        for (i = 0; i < power; i += 1) {\n            for (x = 0; x < sectionSize + 1; x += 1) {\n                srcPos = (xSize * y + x) * 4;\n                r = scratchData.data[srcPos + 0];\n                g = scratchData.data[srcPos + 1];\n                b = scratchData.data[srcPos + 2];\n                a = scratchData.data[srcPos + 3];\n                dstPos = (xSize * y + sectionSize * 2 - x - 1) * 4;\n                scratchData.data[dstPos + 0] = r;\n                scratchData.data[dstPos + 1] = g;\n                scratchData.data[dstPos + 2] = b;\n                scratchData.data[dstPos + 3] = a;\n            }\n            sectionSize *= 2;\n        }\n    }\n    FromPolar(scratchData, imageData, { polarRotation: 0 });\n};\nexports.Kaleidoscope = Kaleidoscope;\nFactory_1.Factory.addGetterSetter(Node_1.Node, 'kaleidoscopePower', 2, (0, Validators_1.getNumberValidator)(), Factory_1.Factory.afterSetFilter);\nFactory_1.Factory.addGetterSetter(Node_1.Node, 'kaleidoscopeAngle', 0, (0, Validators_1.getNumberValidator)(), Factory_1.Factory.afterSetFilter);\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}