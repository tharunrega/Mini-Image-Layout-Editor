{"ast":null,"code":"var React = require('react');\nmodule.exports = function useImage(url, crossOrigin, referrerpolicy) {\n  // lets use refs for image and status\n  // so we can update them during render\n  // to have instant update in status/image when new data comes in\n  const statusRef = React.useRef('loading');\n  const imageRef = React.useRef();\n\n  // we are not going to use token\n  // but we need to just to trigger state update\n  const [_, setStateToken] = React.useState(0);\n\n  // keep track of old props to trigger changes\n  const oldUrl = React.useRef();\n  const oldCrossOrigin = React.useRef();\n  const oldReferrerPolicy = React.useRef();\n  if (oldUrl.current !== url || oldCrossOrigin.current !== crossOrigin || oldReferrerPolicy.current !== referrerpolicy) {\n    statusRef.current = 'loading';\n    imageRef.current = undefined;\n    oldUrl.current = url;\n    oldCrossOrigin.current = crossOrigin;\n    oldReferrerPolicy.current = referrerpolicy;\n  }\n  React.useLayoutEffect(function () {\n    if (!url) return;\n    var img = document.createElement('img');\n    function onload() {\n      img\n      // in Polotno app I found a case when loaded image was not rendered correctly at the first attempt\n      // I found that decoding it manually fixes the issue\n      // also it may be good idea decode it that way, so the work is done in the background\n      // and we don't block the main thread\n      // in context of canvas rendering, large images is a common case\n      .decode()\n      // catch and ignore decode errors because decode may fail but still will render just fine with drawImage on canvas.\n      // I got that case with very large image and chrome\n      .catch(() => {\n        // Intentionally ignore decode errors - image can still render fine on canvas\n      }).finally(() => {\n        statusRef.current = 'loaded';\n        imageRef.current = img;\n        setStateToken(Math.random());\n      });\n    }\n    function onerror() {\n      statusRef.current = 'failed';\n      imageRef.current = undefined;\n      setStateToken(Math.random());\n    }\n    img.addEventListener('load', onload);\n    img.addEventListener('error', onerror);\n    crossOrigin && (img.crossOrigin = crossOrigin);\n    referrerpolicy && (img.referrerPolicy = referrerpolicy);\n    img.src = url;\n    return function cleanup() {\n      img.removeEventListener('load', onload);\n      img.removeEventListener('error', onerror);\n    };\n  }, [url, crossOrigin, referrerpolicy]);\n\n  // return array because it is better to use in case of several useImage hooks\n  // const [background, backgroundStatus] = useImage(url1);\n  // const [patter] = useImage(url2);\n  return [imageRef.current, statusRef.current];\n};","map":{"version":3,"names":["React","require","module","exports","useImage","url","crossOrigin","referrerpolicy","statusRef","useRef","imageRef","_","setStateToken","useState","oldUrl","oldCrossOrigin","oldReferrerPolicy","current","undefined","useLayoutEffect","img","document","createElement","onload","decode","catch","finally","Math","random","onerror","addEventListener","referrerPolicy","src","cleanup","removeEventListener"],"sources":["C:/Users/tharu/Downloads/mini-layout-editor/mini-layout-editor/node_modules/use-image/index.js"],"sourcesContent":["var React = require('react');\n\nmodule.exports = function useImage(url, crossOrigin, referrerpolicy) {\n  // lets use refs for image and status\n  // so we can update them during render\n  // to have instant update in status/image when new data comes in\n  const statusRef = React.useRef('loading');\n  const imageRef = React.useRef();\n\n  // we are not going to use token\n  // but we need to just to trigger state update\n  const [_, setStateToken] = React.useState(0);\n\n  // keep track of old props to trigger changes\n  const oldUrl = React.useRef();\n  const oldCrossOrigin = React.useRef();\n  const oldReferrerPolicy = React.useRef();\n  if (\n    oldUrl.current !== url ||\n    oldCrossOrigin.current !== crossOrigin ||\n    oldReferrerPolicy.current !== referrerpolicy\n  ) {\n    statusRef.current = 'loading';\n    imageRef.current = undefined;\n    oldUrl.current = url;\n    oldCrossOrigin.current = crossOrigin;\n    oldReferrerPolicy.current = referrerpolicy;\n  }\n\n  React.useLayoutEffect(\n    function () {\n      if (!url) return;\n      var img = document.createElement('img');\n\n      function onload() {\n        img\n          // in Polotno app I found a case when loaded image was not rendered correctly at the first attempt\n          // I found that decoding it manually fixes the issue\n          // also it may be good idea decode it that way, so the work is done in the background\n          // and we don't block the main thread\n          // in context of canvas rendering, large images is a common case\n          .decode()\n          // catch and ignore decode errors because decode may fail but still will render just fine with drawImage on canvas.\n          // I got that case with very large image and chrome\n          .catch(() => {\n            // Intentionally ignore decode errors - image can still render fine on canvas\n          })\n          .finally(() => {\n            statusRef.current = 'loaded';\n            imageRef.current = img;\n            setStateToken(Math.random());\n          });\n      }\n\n      function onerror() {\n        statusRef.current = 'failed';\n        imageRef.current = undefined;\n        setStateToken(Math.random());\n      }\n\n      img.addEventListener('load', onload);\n      img.addEventListener('error', onerror);\n      crossOrigin && (img.crossOrigin = crossOrigin);\n      referrerpolicy && (img.referrerPolicy = referrerpolicy);\n      img.src = url;\n\n      return function cleanup() {\n        img.removeEventListener('load', onload);\n        img.removeEventListener('error', onerror);\n      };\n    },\n    [url, crossOrigin, referrerpolicy]\n  );\n\n  // return array because it is better to use in case of several useImage hooks\n  // const [background, backgroundStatus] = useImage(url1);\n  // const [patter] = useImage(url2);\n  return [imageRef.current, statusRef.current];\n};\n"],"mappings":"AAAA,IAAIA,KAAK,GAAGC,OAAO,CAAC,OAAO,CAAC;AAE5BC,MAAM,CAACC,OAAO,GAAG,SAASC,QAAQA,CAACC,GAAG,EAAEC,WAAW,EAAEC,cAAc,EAAE;EACnE;EACA;EACA;EACA,MAAMC,SAAS,GAAGR,KAAK,CAACS,MAAM,CAAC,SAAS,CAAC;EACzC,MAAMC,QAAQ,GAAGV,KAAK,CAACS,MAAM,CAAC,CAAC;;EAE/B;EACA;EACA,MAAM,CAACE,CAAC,EAAEC,aAAa,CAAC,GAAGZ,KAAK,CAACa,QAAQ,CAAC,CAAC,CAAC;;EAE5C;EACA,MAAMC,MAAM,GAAGd,KAAK,CAACS,MAAM,CAAC,CAAC;EAC7B,MAAMM,cAAc,GAAGf,KAAK,CAACS,MAAM,CAAC,CAAC;EACrC,MAAMO,iBAAiB,GAAGhB,KAAK,CAACS,MAAM,CAAC,CAAC;EACxC,IACEK,MAAM,CAACG,OAAO,KAAKZ,GAAG,IACtBU,cAAc,CAACE,OAAO,KAAKX,WAAW,IACtCU,iBAAiB,CAACC,OAAO,KAAKV,cAAc,EAC5C;IACAC,SAAS,CAACS,OAAO,GAAG,SAAS;IAC7BP,QAAQ,CAACO,OAAO,GAAGC,SAAS;IAC5BJ,MAAM,CAACG,OAAO,GAAGZ,GAAG;IACpBU,cAAc,CAACE,OAAO,GAAGX,WAAW;IACpCU,iBAAiB,CAACC,OAAO,GAAGV,cAAc;EAC5C;EAEAP,KAAK,CAACmB,eAAe,CACnB,YAAY;IACV,IAAI,CAACd,GAAG,EAAE;IACV,IAAIe,GAAG,GAAGC,QAAQ,CAACC,aAAa,CAAC,KAAK,CAAC;IAEvC,SAASC,MAAMA,CAAA,EAAG;MAChBH;MACE;MACA;MACA;MACA;MACA;MAAA,CACCI,MAAM,CAAC;MACR;MACA;MAAA,CACCC,KAAK,CAAC,MAAM;QACX;MAAA,CACD,CAAC,CACDC,OAAO,CAAC,MAAM;QACblB,SAAS,CAACS,OAAO,GAAG,QAAQ;QAC5BP,QAAQ,CAACO,OAAO,GAAGG,GAAG;QACtBR,aAAa,CAACe,IAAI,CAACC,MAAM,CAAC,CAAC,CAAC;MAC9B,CAAC,CAAC;IACN;IAEA,SAASC,OAAOA,CAAA,EAAG;MACjBrB,SAAS,CAACS,OAAO,GAAG,QAAQ;MAC5BP,QAAQ,CAACO,OAAO,GAAGC,SAAS;MAC5BN,aAAa,CAACe,IAAI,CAACC,MAAM,CAAC,CAAC,CAAC;IAC9B;IAEAR,GAAG,CAACU,gBAAgB,CAAC,MAAM,EAAEP,MAAM,CAAC;IACpCH,GAAG,CAACU,gBAAgB,CAAC,OAAO,EAAED,OAAO,CAAC;IACtCvB,WAAW,KAAKc,GAAG,CAACd,WAAW,GAAGA,WAAW,CAAC;IAC9CC,cAAc,KAAKa,GAAG,CAACW,cAAc,GAAGxB,cAAc,CAAC;IACvDa,GAAG,CAACY,GAAG,GAAG3B,GAAG;IAEb,OAAO,SAAS4B,OAAOA,CAAA,EAAG;MACxBb,GAAG,CAACc,mBAAmB,CAAC,MAAM,EAAEX,MAAM,CAAC;MACvCH,GAAG,CAACc,mBAAmB,CAAC,OAAO,EAAEL,OAAO,CAAC;IAC3C,CAAC;EACH,CAAC,EACD,CAACxB,GAAG,EAAEC,WAAW,EAAEC,cAAc,CACnC,CAAC;;EAED;EACA;EACA;EACA,OAAO,CAACG,QAAQ,CAACO,OAAO,EAAET,SAAS,CAACS,OAAO,CAAC;AAC9C,CAAC","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}